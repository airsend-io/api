<?php
/*******************************************************************************
 * Copyright(c) 2019 CodeLathe. All rights Reserved.
 *******************************************************************************/

namespace CodeLathe\Core\Managers\OAuth;

use Codeception\Command\Shared\Config;
use CodeLathe\Application\ConfigRegistry;
use CodeLathe\Core\Data\DataController;
use CodeLathe\Core\Exception\ASException;
use CodeLathe\Core\Exception\DatabaseException;
use CodeLathe\Core\Exception\FSOpException;
use CodeLathe\Core\Exception\TeamOpException;
use CodeLathe\Core\Exception\UnknownPolicyEntityException;
use CodeLathe\Core\Exception\UserOpException;
use CodeLathe\Core\Managers\User\UserOperations;
use CodeLathe\Core\Objects\ExternalIdentity;
use CodeLathe\Core\Objects\User;
use CodeLathe\Core\Utility\JsonOutput;
use CodeLathe\Core\Utility\StringUtility;
use Hybridauth\User\Profile;
use Psr\Log\LoggerInterface;

class OAuthOperations
{
    /**
     * @var DataController
     */
    protected $dataController;

    /**
     * @var LoggerInterface
     */
    protected $logger;

    /**
     * @var FileOperations
     */
    protected $userOps;

    /**
     * @var EventManager
     */
    protected $eventManager;

    /**
     * @var ConfigRegistry
     */
    protected $config;

    /**
     * UserOperations constructor.
     *
     * @param DataController $dataController
     * @param LoggerInterface $logger
     * @param UserOperations $userOps
     * @param ConfigRegistry $config
     */
    public function __construct(DataController $dataController,
        LoggerInterface $logger,
        UserOperations $userOps,
        ConfigRegistry $config)
    {
        $this->dataController = $dataController;
        $this->logger = $logger;
        $this->userOps = $userOps;
        $this->config = $config;
    }

    protected function updateUser(User $user, bool $clearPassword = false)
    {
        $doUpdate = false;
        switch($user->getAccountStatus())
        {
            case User::ACCOUNT_STATUS_PENDING_VERIFICATION:
            case User::ACCOUNT_STATUS_PENDING_FINALIZE:
                $doUpdate = true;
                $user->setAccountStatus(User::ACCOUNT_STATUS_ACTIVE);
                break;
            case User::ACCOUNT_STATUS_ACTIVE:
                break;
            default:
                $this->logger->debug("Login Failed. Invalid account status for user " . $user->getEmailOrPhone());
                throw new UserOpException("Invalid Account Status");
        }

        if ($user->getApprovalStatus() ==  User::APPROVAL_STATUS_PENDING){
            $doUpdate = true;
            $user->setApprovalStatus(User::APPROVAL_STATUS_APPROVED);
        }


        if (!$user->getIsEmailVerified()){
            $doUpdate = true;
            $user->setIsEmailVerified(true);
        }

        if ($user->getTrustLevel() == User::USER_TRUST_LEVEL_UNKNOWN){
            $doUpdate = true;
            $user->setTrustLevel(User::USER_TRUST_LEVEL_BASIC);
        }

        if ($user->getUserRole() == User::USER_ROLE_VIEWER){
            $doUpdate = true;
            $user->setUserRole(User::USER_ROLE_EDITOR);
        }

        if ($clearPassword) {
            $doUpdate = true;
            $user->setPassword('');
            $user->setIsAutoGeneratedPassword(true);
        }

        if ($doUpdate) {
            $this->dataController->updateUser($user);
        }
    }


    /**
     * login for oauth
     *
     * @param Profile $extProfile
     * @param int $provider
     * @return User|null
     * @throws ASException
     * @throws UserOpException
     * @deprecated Only used by linked in
     */
    public function login(Profile $extProfile, int $provider)
    {
        if ($extProfile->email != $extProfile->emailVerified) {
            throw new UserOpException("Email not verified");
        }

        /** check for existing user record */
        $user = $this->dataController->getUserByEmail($extProfile->email);
        if (empty($user)) {
            try {

                $createDisabled = (int)$this->config->get('/app/disable_account_creation');
                if ($createDisabled == 1) {
                    throw new UserOpException("Disabled");
                }

                $user = $this->userOps->createUser($extProfile->email, null, StringUtility::generateRandomString(12),
                                                    $extProfile->displayName,User::ACCOUNT_STATUS_ACTIVE,
                                            User::USER_ROLE_EDITOR,User::APPROVAL_STATUS_APPROVED,
                                        true);
            }
            catch(ASException $ex){
                 throw $ex;
            }
        }

        /** check for external identity record */
        $clearPassword = false;
        $extIdentity = $this->dataController->getExternalIdentity($user->getId(), $extProfile->email, $provider);
        if (empty($extIdentity)) {
                $extIdentity = ExternalIdentity::create($user->getId(), $extProfile->email, $extProfile->displayName,
                                                        $provider, $extProfile->identifier);
                if (!$this->dataController->createExternalIdentity($extIdentity)) {
                    throw new UserOpException("Cannot create external identity record");
                }

                // when a new external identity is created for a user, it's password have to be cleared
                // to prevent account takeover attack
                $clearPassword = true;
        }

        $this->updateUser($user, $clearPassword);

        return $user;
    }


    /**
     * @param string $externalIdentifier
     * @param string $email
     * @param string $displayName
     * @param bool $emailVerified
     * @param int $provider
     * @param bool $accountCreated
     * @return User|null
     * @throws ASException
     * @throws UserOpException
     * @throws DatabaseException
     * @throws FSOpException
     * @throws TeamOpException
     * @throws UnknownPolicyEntityException
     */
    public function loginDirect(string $externalIdentifier, string $email, string $displayName, bool $emailVerified, int $provider, bool &$accountCreated) : ?User
    {
        if (!$emailVerified) {
            throw new UserOpException("Email not verified");
        }

        $clearPassword = false;

        // first verify if the external id already exists for this provider
        $externalIdentity = $this->dataController->getExternalIdentityById($externalIdentifier, $provider);
        if ($externalIdentity !== null) {

            // check for existing user record by id
            $user = $this->dataController->getUserById($externalIdentity->getUserId());

            // check if the emails don't match (only happens when the email address changed on the provider)
            // update the user email, and ask for a new validation of the new email
            if (!empty($user) && $user->getEmail() !== $email) {

                $user->setEmail($email);
                $user->setIsEmailVerified(false);
                $this->dataController->updateUser($user);

                $externalIdentity->setEmail($email);
                $this->dataController->updateExternalIdentity($externalIdentity);

            }

        } else {

            // check for existing user record by email (create it if don't exist)
            $user = $this->dataController->getUserByEmail($email);
            if (empty($user)) {
                try {

                    $createDisabled = (int)$this->config->get('/app/disable_account_creation');
                    if ($createDisabled == 1) {
                        throw new UserOpException("Disabled");
                    }

                    $user = $this->userOps->createUser($email, null, StringUtility::generateRandomString(12),
                        $displayName,User::ACCOUNT_STATUS_ACTIVE,
                        User::USER_ROLE_EDITOR,User::APPROVAL_STATUS_APPROVED,
                        true);
                } catch(ASException $e){
                    throw $e;
                }
                $accountCreated = true;
            }

            // create the external identity
            $externalIdentity = ExternalIdentity::create($user->getId(),
                $email,
                $displayName,
                $provider,
                $externalIdentifier);
            if (!$this->dataController->createExternalIdentity($externalIdentity)) {
                // this should never happen
                throw new UserOpException("Cannot create external identity record");
            }

            // when a new external identity is created/updated for a user, it's password have to be cleared
            // to prevent account takeover attack
            $clearPassword = true;

        }

        $this->updateUser($user, $clearPassword);

        return $user;
    }



}